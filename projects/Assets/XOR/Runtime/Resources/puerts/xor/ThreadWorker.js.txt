"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const csharp = require("csharp");
const puerts_1 = require("puerts");
let List_Object = (0, puerts_1.$generic)(csharp.System.Collections.Generic.List$1, csharp.System.Object);
const INVOKE_TICK = Symbol("INVOKE_TICK");
const CLOSE_EVENT = "__e_close__", REMOTE_EVENT = "__e_remote__", RESULT_EVENT = "__e_result__";
class ThreadWorkerImpl {
    constructor(loader, options) {
        if (loader instanceof csharp.XOR.ThreadWorker) {
            this.worker = loader;
            this.mainThread = false;
        }
        else {
            this.worker = csharp.XOR.ThreadWorker.Create(loader, options);
            this.mainThread = true;
        }
        this.worker.VerifyThread(this.mainThread);
        this.events = new Map();
        this.register();
    }
    start(filepath) {
        if (!this.mainThread || XOR.globalWorker && XOR.globalWorker.worker === this.worker)
            throw new Error("Invalid operation ");
        this.worker.Run(filepath);
    }
    stop() {
        if (this.mainThread) {
            this.events.clear();
            this.worker.Dispose();
        }
        else {
            this.post(CLOSE_EVENT);
        }
    }
    post(eventName, data, notResult) {
        let edata;
        if (data !== undefined && data !== null && data !== void 0) {
            edata = this.pack(data);
        }
        let resultId = this.getResultId();
        if (this.mainThread) {
            this.worker.PostToChildThread(eventName, edata, resultId);
        }
        else {
            this.worker.PostToMainThread(eventName, edata, resultId);
        }
        if (resultId) {
            return new Promise((resolve, reject) => {
                this.once(resultId, function (d) {
                    if (d.error)
                        reject(d.error);
                    else
                        resolve(d.result);
                });
            });
        }
    }
    postSync(eventName, data, throwOnError = true) {
        let edata;
        if (data !== undefined && data !== null && data !== void 0) {
            edata = this.pack(data);
        }
        let result;
        if (this.mainThread) {
            edata = this.worker.Syncr.PostToChildThread(eventName, edata, throwOnError);
        }
        else {
            edata = this.worker.Syncr.PostToMainThread(eventName, edata, throwOnError);
        }
        if (edata !== undefined && edata !== null && edata !== void 0) {
            result = this.unpack(edata);
        }
        return result;
    }
    eval(chunk, chunkName) {
        if (!this.mainThread || XOR.globalWorker && XOR.globalWorker.worker === this.worker)
            throw new Error("Invalid operation ");
        this.worker.PostEvalToChildThread(chunk, chunkName);
    }
    on() {
        let eventName = arguments[0], fn = arguments[1];
        delete fn[INVOKE_TICK];
        this._on(eventName, fn);
        return this;
    }
    once(eventName, fn) {
        fn[INVOKE_TICK] = 1;
        this._on(eventName, fn);
        return this;
    }
    remove(eventName, fn) {
        let funcs = this.events.get(eventName);
        if (funcs) {
            let idx = funcs.indexOf(fn);
            if (idx >= 0) {
                funcs.splice(idx, 1);
            }
        }
    }
    removeAll(eventName) {
        if (eventName)
            this.events.delete(eventName);
        else
            this.events.clear();
    }
    _on(eventName, fn) {
        if (eventName && fn) {
            let funcs = this.events.get(eventName);
            if (!funcs) {
                funcs = [];
                this.events.set(eventName, funcs);
            }
            funcs.push(fn);
        }
    }
    _emit(eventName, ...args) {
        let functions = this.events.get(eventName);
        if (!functions)
            return null;
        let rmHandlers = new Array(), result;
        functions.forEach(func => {
            let r = func.apply(undefined, args);
            result = result ?? r;
            if (INVOKE_TICK in func && (--func[INVOKE_TICK]) <= 0) {
                rmHandlers.push(func);
            }
        });
        if (rmHandlers.length > 0) {
            this.events.set(eventName, functions.filter(func => !rmHandlers.includes(func)));
        }
        return result;
    }
    register() {
        let getValue = (data) => {
            if (data !== undefined && data !== null && data !== void 0) {
                return this.unpack(data);
            }
            return null;
        };
        let onmessage = (eventName, data, hasReturn = true) => {
            if (eventName && eventName.startsWith(RESULT_EVENT)) {
                let error, result;
                if (data.Type === csharp.XOR.ThreadWorker.ValueType.ERROR) {
                    error = new Error(`${data.Value}`);
                }
                else {
                    result = getValue(data);
                }
                this._emit(eventName, { error, result });
                return;
            }
            let result = this._emit(eventName, getValue(data));
            if (hasReturn && result !== undefined && result !== null && result !== void 0)
                return this.pack(result);
            return null;
        };
        if (this.mainThread) {
            this.worker.MainThreadHandler = (eventName, data) => {
                switch (eventName) {
                    case CLOSE_EVENT:
                        {
                            let closing = true;
                            let funcs = this.events.get(CLOSE_EVENT);
                            if (funcs) {
                                let _data = getValue(data);
                                for (let fn of funcs) {
                                    if (fn(_data) === false) {
                                        closing = false;
                                    }
                                }
                            }
                            if (closing)
                                this.stop();
                            return this.pack(closing);
                        }
                        break;
                    case REMOTE_EVENT:
                        {
                            return this.resolveRemote(getValue(data));
                        }
                        break;
                    default:
                        return onmessage(eventName, data);
                        break;
                }
            };
        }
        else {
            this.worker.ChildThreadHandler = onmessage;
            if (this.worker.Options && this.worker.Options.Remote) {
                this.registerRemoteProxy();
            }
        }
    }
    registerRemoteProxy() {
        let createProxy = (namespace) => {
            return new Proxy(Object.create(null), {
                get: (cache, name) => {
                    if (!(name in cache) && typeof (name) === "string") {
                        let fullName = namespace ? (namespace + '.' + name) : name;
                        if (fullName.startsWith("UnityEngine") && fullName !== "UnityEngine.Debug") {
                            console.log(`request: ${fullName}`);
                            let cls = this.postSync(REMOTE_EVENT, fullName);
                            console.log(`response: (${typeof (cls)})${cls}`);
                            if (cls) {
                                cache[name] = cls;
                            }
                            else {
                                cache[name] = createProxy(fullName);
                            }
                        }
                        else {
                            let value = csharp;
                            fullName.split(".").forEach(name => {
                                if (value && name) {
                                    value = value[name];
                                }
                            });
                            cache[name] = value;
                        }
                    }
                    return cache[name];
                }
            });
        };
        let puerts = require("puerts");
        puerts.registerBuildinModule('csharp', createProxy(undefined));
    }
    resolveRemote(data) {
        if (typeof data !== "string")
            return null;
        let result = csharp;
        data.split(".").forEach(name => {
            if (result && name)
                result = result[name];
        });
        let t = typeof (result);
        if (t !== "undefined" && t !== "object" && t !== "function") {
            return this.pack(result);
        }
        switch (typeof (result)) {
            case "number":
            case "string":
            case "bigint":
            case "boolean":
            case "object":
                return this.pack(result);
                break;
            case "function":
                return null;
                break;
            default:
                return null;
                break;
        }
    }
    getResultId() {
        if (!this._postIndex)
            this._postIndex = 1;
        return `${RESULT_EVENT}${this._postIndex++}`;
    }
    pack(data) {
        switch (this._validate(data)) {
            case 0:
                {
                    let result = new csharp.XOR.ThreadWorker.EventData();
                    if (typeof (data) === "object") {
                        result.Type = csharp.XOR.ThreadWorker.ValueType.JSON;
                        result.Value = JSON.stringify(data);
                    }
                    else {
                        result.Type = csharp.XOR.ThreadWorker.ValueType.Value;
                        result.Value = data;
                    }
                    return result;
                }
                break;
            case 1:
                return this._packByRefs(data, { mapping: new WeakMap(), id: 1 });
                break;
            case 2:
                throw new Error("unsupport data");
                break;
        }
        return null;
    }
    unpack(data) {
        switch (data.Type) {
            case csharp.XOR.ThreadWorker.ValueType.JSON:
                return JSON.parse(data.Value);
                break;
            default:
                return this._unpackByRefs(data, new Map());
                break;
        }
        return null;
    }
    _packByRefs(data, refs) {
        let result = new csharp.XOR.ThreadWorker.EventData();
        let t = typeof (data);
        if (t === "object" && refs.mapping.has(data)) {
            result.Type = csharp.XOR.ThreadWorker.ValueType.RefObject;
            result.Value = refs.mapping.get(data) ?? -1;
        }
        else {
            switch (t) {
                case "object":
                    let id = refs.id++;
                    refs.mapping.set(data, id);
                    result.Id = id;
                    if (data instanceof csharp.System.Object) {
                        result.Type = csharp.XOR.ThreadWorker.ValueType.Value;
                        result.Value = data;
                    }
                    else if (data instanceof ArrayBuffer) {
                        result.Type = csharp.XOR.ThreadWorker.ValueType.ArrayBuffer;
                        result.Value = csharp.XOR.BufferUtil.ToBytes(data);
                    }
                    else if (Array.isArray(data)) {
                        let list = new List_Object();
                        for (let i = 0; i < data.length; i++) {
                            let member = this._packByRefs(data[i], refs);
                            member.Key = i;
                            list.Add(member);
                        }
                        result.Type = csharp.XOR.ThreadWorker.ValueType.Array;
                        result.Value = list;
                    }
                    else {
                        let list = new List_Object();
                        Object.keys(data).forEach(key => {
                            let item = this._packByRefs(data[key], refs);
                            item.Key = key;
                            list.Add(item);
                        });
                        result.Type = csharp.XOR.ThreadWorker.ValueType.Object;
                        result.Value = list;
                    }
                    break;
                case "string":
                case "number":
                case "bigint":
                case "boolean":
                    result.Type = csharp.XOR.ThreadWorker.ValueType.Value;
                    result.Value = data;
                    break;
                default:
                    result.Type = csharp.XOR.ThreadWorker.ValueType.Unknown;
                    break;
            }
        }
        return result;
    }
    _unpackByRefs(data, refs) {
        const { Type, Value, Id } = data;
        let result;
        switch (Type) {
            case csharp.XOR.ThreadWorker.ValueType.Object:
                {
                    result = {};
                    if (Id > 0)
                        refs.set(Id, result);
                    let list = Value;
                    for (let i = 0; i < list.Count; i++) {
                        let member = list.get_Item(i);
                        result[member.Key] = this._unpackByRefs(member, refs);
                    }
                }
                break;
            case csharp.XOR.ThreadWorker.ValueType.Array:
                {
                    result = [];
                    if (Id > 0)
                        refs.set(Id, result);
                    let list = Value;
                    for (let i = 0; i < list.Count; i++) {
                        let member = list.get_Item(i);
                        result[member.Key] = this._unpackByRefs(member, refs);
                    }
                }
                break;
            case csharp.XOR.ThreadWorker.ValueType.ArrayBuffer:
                result = csharp.XOR.BufferUtil.ToBuffer(Value);
                if (Id > 0)
                    refs.set(Id, result);
                break;
            case csharp.XOR.ThreadWorker.ValueType.RefObject:
                if (refs.has(Value)) {
                    result = refs.get(Value);
                }
                else {
                    result = `Error: ref id ${Value} not found`;
                }
                break;
            case csharp.XOR.ThreadWorker.ValueType.JSON:
                result = JSON.parse(data.Value);
                if (Id > 0)
                    refs.set(Id, result);
                break;
            default:
                result = Value;
                if (Id > 0)
                    refs.set(Id, result);
                break;
        }
        return result;
    }
    _validate(data, refs) {
        let t = typeof (data);
        switch (t) {
            case "object":
                if (data instanceof csharp.System.Object ||
                    data instanceof ArrayBuffer) {
                    return 1;
                }
                if (!refs)
                    refs = new WeakSet();
                if (refs.has(data)) {
                    return 1;
                }
                refs.add(data);
                if (Array.isArray(data)) {
                    for (let _d of data) {
                        let t = this._validate(_d, refs);
                        if (t > 0)
                            return t;
                    }
                }
                else {
                    for (let key of Object.keys(data)) {
                        let t = this._validate(key, refs);
                        if (t > 0)
                            return t;
                        t = this._validate(data[key], refs);
                        if (t > 0)
                            return t;
                    }
                }
                break;
            case "symbol":
            case "function":
                return 2;
                break;
        }
        return 0;
    }
}
(function () {
    let _g = (global ?? globalThis ?? this);
    _g["ThreadWorker"] = ThreadWorkerImpl;
    _g["globalWorker"] = undefined;
})();
function register() {
    let _g = (global ?? globalThis ?? this);
    _g.XOR = _g.XOR || {};
    _g.XOR["ThreadWorker"] = ThreadWorkerImpl;
    _g.XOR["globalWorker"] = undefined;
}
register();
//# sourceMappingURL=ThreadWorker.js.map